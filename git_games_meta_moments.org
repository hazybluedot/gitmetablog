* Meta Momements
I had a bit of a meta moment while swimming today. I have a lot of
good moments while swimming, probably because it's a chance for my
mind to wander.  That's probably a good argument to go more often than
I did this past week.  But I digress.

Yesterday I was introduced to a [[ http://pcottle.github.com/learnGitBranching/][game of sorts]] to help learn some
concepts used by [[http://git-scm.com/about][git]].  For those of you who don't know, git is a
versioning control system that has gained quit a bit of popularity
over the past few years, especially in the open source community.  I
had been using it myself for my own projects, but mainly at a very
simplistic level.

At one level, a versioning control system (VCS), of which git is
one of many, is a tool to facilitate documenting the changes
of... well, a document. Historically these systems were develped by
software designers to both document changes and provide an easy path
to revert to older versions of source code. Later, similar concepts
were implemented in modern word processors (with limited scope and
power due to the restrictive nature, essentially the traditional
method of tracking edits from the pen and paper days was ported over
to the electronic medium without much change). 

One thing that became much more clear to me after trying out the git
game was that while providing logical "snapshots" of a project that
can be used as a return point if somethign goes astray in the future,
git is creating a history of the project, a history that tells a
story. But unlike other histories you may be familiar with, the
history generated by git can be rewritten to change the past.

What had alluded me up until this point was what motivation one might
have to rewrite history.  I figured, you make changes, commit them to
the project, those changes get recorded, what more would you need?
Well, it turns out that with the ability to rewrite history, git makes
it incredibly easy to do certain types of edits on your data and
allows an author to use git more as a tool for trying out new,
possibly risky ideas, or take off on a tangent while always providing
a clear path back to a ground point.

** Removing Trace Code
As one example, something I find myself doing often in my own code is
debugging a peculiar behavior.  This often involves adding trace code
to my program to print out the state of certain variables during key
parts of the program.  When I finally track down the problem and fix
it, I go back and remove the trace code I added and my final git log
looks something like this:

- (1) everything resolved except for bug X
- (2) add trace code
- (3) add more trace code
- (4) more trace code (where the heck is this thing?)
- (5) fix bug X!!!
- (6) remove trace code
- (7) add feature Y
- (8) remove previously missed trace code from debugging process
- (9) find yet more old trace code and removed it

You get the idea. Being the imperfect being that I am, I don't always
remember EVERY point I added trace code during a long debugging
process, and so I miss some and then catch it later when I'm reviewing
my log files.  And then I catch more, and remove it too.  All steps
that I really don't need to take, because git has a perfect memory of
what trace code I added (dependent on the accuracy of my commits, of
course).

I could have saved myself a lot of time if after finally fixing bug X
I had just told git to discard the edits I made to add trace code.
Those bits of history don't really add any useful information to the
project.
